open Batteries

module C = Control
module T = TypedAst
module TS = Control.ThreadStructure

module type Application = sig
  type state
  type interference

  val apply :
    Control.Label.t ->
    state ->
    interference ->
    state * interference

  val generate :
    Operation.t ->
    Control.Label.t ->
    Control.Label.t ->
    state ->
    state * interference
end

module type ThreadAnalysis = sig
  module StateAbstraction : Domain.ThreadState
  module Interferences : Domain.Interferences
  module Application : Application
    with type state = StateAbstraction.t
     and type interference = Interferences.t
end

module OneThreadAnalysis (A : ThreadAnalysis) = struct
  (* TODO: better WTO for one-thread graphs *)
  (* TODO: separate widening delays for different operations *)
  module Wto = Graph.WeakTopological.Make (TS.Graph)

  let analyse prog thread_id thread_controls widening_delay old_data external_intf =
    (* Data has to be redefined at each thread analysis because the
       analyze function should depend on the external interferences. *)
    let intf_bot = A.Interferences.bottom prog thread_controls in

    let apply_interferences lbl w_delay state =
      let rec aux w_delay state new_intf =
        let result, intf = A.Application.apply lbl state external_intf in
        let result = A.StateAbstraction.join state result in
        let new_intf = A.Interferences.join new_intf intf in
        if A.StateAbstraction.equal state result then result, new_intf
        else if w_delay > 0 then aux (w_delay - 1) result new_intf
        else aux 0 (A.StateAbstraction.widening state result) new_intf
      in aux w_delay state intf_bot
    in

    let module Data = struct
      type t = A.StateAbstraction.t
      type edge = TS.Graph.edge
      let equal = A.StateAbstraction.equal
      let join = A.StateAbstraction.join
      let widening = A.StateAbstraction.widening

      let return_interferences, analyze =
        (* Use closures to update generated interferences without
           having an explicit global state *)
        let interf = ref intf_bot in
        (fun () -> !interf),
        (fun (lbl1, op, lbl2) state ->
           let state', interf' = A.Application.generate op lbl1 lbl2 state in
           let state'', interf'' = apply_interferences lbl2 widening_delay state' in
           let new_intf = A.Interferences.join interf' interf'' in
           interf := A.Interferences.join !interf new_intf;
           state'')
    end in
    let module Fixpoint = Graph.ChaoticIteration.Make (TS.Graph) (Data) in

    let thread_control = List.at thread_controls thread_id in

    let wto =
      Wto.recursive_scc thread_control.TS.graph @@
      Control.Label.initial in

    let set_initial_thread_label thread_id _thread abstr =
      (* Sets in abstr the label of thread_id to initial.
         Conveniently has the right type to use with List.fold_righti
         in `init` below *)
      A.StateAbstraction.meet_label thread_id Control.Label.initial abstr
    in

    let init label =
      if Control.Label.is_initial label
      then
        A.StateAbstraction.top prog thread_controls thread_id
        (* Meet with initial condition of the program *)
        |> A.StateAbstraction.meet_cond prog.TypedAst.initial
        (* Set all thread labels to zero *)
        |> List.fold_righti set_initial_thread_label prog.T.threads
        |> apply_interferences Control.Label.initial widening_delay
        |> fst (* No interference should be generated at the initial state *)
      else
        (* At first analysis, old data is expected to map each label
           to bottom. We reuse old data to avoid recomputing some
           steps. *)
        (* A.StateAbstraction.bottom prog thread_controls thread_id *)
        old_data label
    in

    let widening_set =
      Graph.ChaoticIteration.FromWto
    in

    let result =
      Fixpoint.recurse
        thread_control.TS.graph
        wto
        init
        widening_set
        widening_delay
    in

    Data.return_interferences (),
    fun state -> Fixpoint.M.find state result
end

module ProgramAnalysis (A : ThreadAnalysis) = struct
  module ThreadAnalysis = OneThreadAnalysis (A)

  let analyse prog thread_controls state_delay interf_delay =

    let interf_bot = A.Interferences.bottom prog thread_controls in

    let split_interferences thread_index =
      (* Takes the list of the interferences generated by each thread
         and returns a couple (intf_tid, intf_others) where i_tid is the
         interference set generated by thread_index and i_others is the
         join of all others *)
      List.fold_lefti
        (fun (intf_tid, intf_others) index intf_index ->
           if thread_index = index
           then (intf_index, intf_others)
           else (intf_tid, A.Interferences.join intf_others intf_index))
        (interf_bot, interf_bot)
    in

    let initial_thread_data thread_id _thread_control =
      fun _label -> A.StateAbstraction.bottom prog thread_controls thread_id
    in

    let initial_data =
      List.mapi initial_thread_data thread_controls in

    let rec fixpoint interf interf_w_delays data current final = function
      (* current is the id option of the thread the function is going
         to analyse. final is the id of the last thread which changed
         its interference set. That means other threads did not add
         interferences w.r.t the last analysis when the iteration
         reaches this thread again. Therefore fixpoint is reached: all
         thread data have been computed with the last interference
         set, therefore these data cannot change anymore.

         Interference widening works thread by thread. *)
      | [] ->
        (* If no thread generated any interference, we can now stop
           the analysis, which is done by saying that thread 0 was the
           last one to update them *)
        let final = Some (final |? 0) in
        fixpoint interf interf_w_delays data 0 final thread_controls
      | _ :: _ when Some current = final ->
        interf, data
      | _ :: ts ->
        Printf.printf "Analysing thread %d\n%!" current;
        let intf_t, intf_other = split_interferences current interf in
        let old_data = List.at data current in
        let intf_t', d =
          ThreadAnalysis.analyse
            prog current thread_controls state_delay old_data intf_other in
        let intf_t_stable = A.Interferences.equal intf_t intf_t' in
        let final =
          if intf_t_stable
          then final
          else Some current in
        let data =
          List.modify_at current (const d) data in
        let interf, interf_w_delays =
          if intf_t_stable
          then interf, interf_w_delays
          else
            let w_delay = List.at interf_w_delays current in
            let intf_t'', w_delay' =
              if w_delay > 0
              then intf_t', w_delay - 1
              else (Printf.printf "Widening\n%!"; A.Interferences.widening intf_t intf_t', 0)
            in
            List.modify_at current (const intf_t'') interf,
            List.modify_at current (const w_delay') interf_w_delays
        in
        fixpoint interf interf_w_delays data (succ current) final ts
    in
    fixpoint
      (List.map (const interf_bot) thread_controls) (* initial interferences *)
      (List.map (const interf_delay) thread_controls) (* widening delays *)
      initial_data (* initial data for a thread *)
      0 (* first "current analysed state" *)
      None (* Last thread updating interferences *)
      thread_controls
    |> snd (* Return the data, forget the interferences *)
end

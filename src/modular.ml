open Batteries

module C = Control
module T = TypedAst
module TS = Control.ThreadStructure

module type Application = sig
  type state
  type interference

  val apply :
    Control.Label.t ->
    state ->
    interference ->
    state * interference

  val generate :
    Operation.t ->
    Control.Label.t ->
    Control.Label.t ->
    state ->
    state * interference
end

module type ThreadAnalysis = sig
  module StateAbstraction : Domain.ThreadState
  module Interferences : Domain.Interferences
  module Application : Application
    with type state = StateAbstraction.t
     and type interference = Interferences.t
end

module OneThreadAnalysis (A : ThreadAnalysis) = struct
  (* TODO: better WTO for one-thread graphs *)
  (* TODO: separate widening delays for different operations *)
  module Wto = Graph.WeakTopological.Make (TS.Graph)

  let analyse prog thread_id thread_controls widening_delay old_data external_intf =
    (* Data has to be redefined at each thread analysis because the
       analyze function should depend on the external interferences. *)
    let intf_bot = A.Interferences.bottom prog thread_controls in

    let apply_interferences lbl w_delay state =
      let rec aux w_delay state new_intf =
        let result, intf = A.Application.apply lbl state external_intf in
        let result = A.StateAbstraction.join state result in
        let new_intf = A.Interferences.join new_intf intf in
        if A.StateAbstraction.equal state result then result, new_intf
        else if w_delay > 0 then aux (w_delay - 1) result new_intf
        else aux 0 (A.StateAbstraction.widening state result) new_intf
      in aux w_delay state intf_bot
    in

    let module Data = struct
      type t = A.StateAbstraction.t
      type edge = TS.Graph.edge
      let equal = A.StateAbstraction.equal
      let join = A.StateAbstraction.join
      let widening = A.StateAbstraction.widening

      let return_interferences, analyze =
        (* Use closures to update generated interferences without
           having an explicit global state *)
        let interf = ref intf_bot in
        (fun () -> !interf),
        (fun (lbl1, op, lbl2) state ->
           let state', interf' = A.Application.generate op lbl1 lbl2 state in
           let state'', interf'' = apply_interferences lbl2 widening_delay state' in
           let new_intf = A.Interferences.join interf' interf'' in
           interf := A.Interferences.join !interf new_intf;
           state'')
    end in
    let module Fixpoint = Graph.ChaoticIteration.Make (TS.Graph) (Data) in

    let thread_control = List.at thread_controls thread_id in

    let wto =
      Wto.recursive_scc thread_control.TS.graph @@
      Control.Label.initial in

    let set_initial_thread_label thread_id _thread abstr =
      (* Sets in abstr the label of thread_id to initial.
         Conveniently has the right type to use with List.fold_righti
         in `init` below *)
      A.StateAbstraction.meet_label thread_id Control.Label.initial abstr
    in

    let init label =
      if Control.Label.is_initial label
      then
        A.StateAbstraction.top prog thread_controls thread_id
        (* Meet with initial condition of the program *)
        |> A.StateAbstraction.meet_cond prog.TypedAst.initial
        (* Set all thread labels to zero *)
        |> List.fold_righti set_initial_thread_label prog.T.threads
        |> apply_interferences Control.Label.initial widening_delay
        |> fst (* No interference should be generated at the initial state *)
      else
        (* At first analysis, old data is expected to map each label
           to bottom. We reuse old data to avoid recomputing some
           steps. *)
        (* A.StateAbstraction.bottom prog thread_controls thread_id *)
        old_data label
    in

    let widening_set =
      Graph.ChaoticIteration.FromWto
    in

    let result =
      Fixpoint.recurse
        thread_control.TS.graph
        wto
        init
        widening_set
        widening_delay
    in

    Data.return_interferences (),
    fun state -> Fixpoint.M.find state result
end

module ProgramAnalysis (A : ThreadAnalysis) = struct
  module ThreadAnalysis = OneThreadAnalysis (A)

  let analyse param prog thread_controls state_delay interf_delay =

    let interf_bot = A.Interferences.bottom prog thread_controls in

    let split_interferences thread_index =
      (* Takes the list of the interferences generated by each thread
         and returns a couple (intf_tid, intf_others) where i_tid is the
         interference set generated by thread_index and i_others is the
         join of all others *)
      List.fold_lefti
        (fun (intf_tid, intf_others) index intf_index ->
           if thread_index = index
           then (intf_index, intf_others)
           else (intf_tid, A.Interferences.join intf_others intf_index))
        (interf_bot, interf_bot)
    in

    let initial_thread_data thread_id _thread_control =
      fun _label -> A.StateAbstraction.bottom prog thread_controls thread_id
    in

    let initial_data =
      List.mapi initial_thread_data thread_controls in

    let rec sequential intf intf_w_delays data current final = function
      (*
         current is the id option of the thread the function is going
         to analyse.

         final is the id of the thread for which, if the list
         iteration reaches it, we know that the analysis is complete.

         final is None at the beginning. This ensures that a first
         pass will be done. After reaching the end of the list, final
         is set to `Some 0` so that the analysis ends if no thread
         generated any interference at all, which is useful for some
         test programs.

         Interference widening works thread by thread.
      *)
      | [] ->
        let final = Some (final |? 0) in
        sequential intf intf_w_delays data 0 final thread_controls
      | _ :: _ when Some current = final ->
        intf, data
      | _ :: ts ->
        Printf.printf "Analysing thread %d\n%!" current;
        let intf_t, intf_other = split_interferences current intf in
        let old_data = List.at data current in
        let intf_t', d =
          ThreadAnalysis.analyse
            prog current thread_controls state_delay old_data intf_other in
        let intf_t_stable = A.Interferences.equal intf_t intf_t' in
        let final =
          if intf_t_stable
          then final
          else Some current in
        let data =
          List.modify_at current (const d) data in
        let intf, intf_w_delays =
          if intf_t_stable
          then intf, intf_w_delays
          else
            let w_delay = List.at intf_w_delays current in
            let intf_t'', w_delay' =
              if w_delay > 0
              then intf_t', w_delay - 1
              else (Printf.printf "Widening\n%!"; A.Interferences.widening intf_t intf_t', 0)
            in
            List.modify_at current (const intf_t'') intf,
            List.modify_at current (const w_delay') intf_w_delays
        in
        sequential intf intf_w_delays data (succ current) final ts

    in

    let rec parallel all_intf_stable old_intf new_intf intf_w_delays data current = function
      (*
         current is the id option of the thread the function is going
         to analyse.

         Interference widening works thread by thread.
      *)
      | [] ->
        if all_intf_stable
        then new_intf, data
        else
          parallel true new_intf new_intf intf_w_delays data 0 thread_controls
      | _ :: ts ->
        Printf.printf "Analysing thread %d\n%!" current;
        let old_intf_t, old_intf_other = split_interferences current old_intf in
        let old_data = List.at data current in
        let new_intf_t, new_data =
          ThreadAnalysis.analyse
            prog current thread_controls state_delay old_data old_intf_other in
        let intf_t_stable = A.Interferences.equal old_intf_t new_intf_t in
        let all_intf_stable = all_intf_stable && intf_t_stable in
        let data = List.modify_at current (const new_data) data in
        let new_intf, intf_w_delays =
          if intf_t_stable
          then new_intf, intf_w_delays
          else
            let w_delay = List.at intf_w_delays current in
            let new_intf_t, w_delay' =
              if w_delay > 0
              then new_intf_t, w_delay - 1
              else (Printf.printf "Widening\n%!"; A.Interferences.widening old_intf_t new_intf_t, 0)
            in
            List.modify_at current (const new_intf_t) new_intf,
            List.modify_at current (const w_delay') intf_w_delays
        in
        parallel all_intf_stable old_intf new_intf intf_w_delays data (succ current) ts

    in

    if param.Param.parallel
    then
      parallel
        true (* "All" the zero interferences are stable *)
        (List.map (const interf_bot) thread_controls) (* initial old interferences *)
        (List.map (const interf_bot) thread_controls) (* initial new interferences *)
        (List.map (const interf_delay) thread_controls) (* widening delays *)
        initial_data (* initial data for a thread *)
        0 (* first "current analysed state" *)
        thread_controls
    else
      sequential
        (List.map (const interf_bot) thread_controls) (* initial interferences *)
        (List.map (const interf_delay) thread_controls) (* widening delays *)
        initial_data (* initial data for a thread *)
        0 (* first "current analysed state" *)
        None (* Last thread updating interferences *)
        thread_controls
end
